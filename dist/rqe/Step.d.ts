import { Graph, QueryExecutionContext } from './Graph';
import { QueryLike, QueryParameters, QueryModifier } from './Query';
import { Stream } from './Stream';
import { StoredQuery } from './StoredQuery';
import { QueryPlan, PlannedStep } from './Plan';
import { Item } from './Item';
import { ErrorItem } from './Errors';
import { QueryTuple } from './QueryTuple';
import { MountPointRef } from './MountPoint';
import { Trace } from './Trace';
import { RunningQuery } from './RunningQuery';
interface ConstructorArgs {
    id?: number;
    graph: Graph;
    tuple: QueryTuple;
    afterVerb: QueryTuple;
    input: Stream;
    output: Stream;
    context: QueryExecutionContext;
    planned?: QueryPlan;
    plannedStep?: PlannedStep;
    running?: RunningQuery;
    trace?: Trace;
}
export declare class Step {
    id: number;
    tuple: QueryTuple;
    afterVerb: QueryTuple;
    graph: Graph;
    input: Stream;
    output: Stream;
    context: QueryExecutionContext;
    planned: QueryPlan;
    plannedStep: PlannedStep;
    running: RunningQuery;
    incomingSchema: Item[];
    schemaOnly: boolean;
    sawUsedMounts: MountPointRef[];
    declaredAsync: boolean;
    declaredStreaming: boolean;
    trace: Trace;
    constructor(args: ConstructorArgs);
    has(attr: string): boolean;
    hasValue(attr: string): boolean;
    getIncomingSchema(): import("./Plan").ExpectedValue;
    query(queryLike: QueryLike, parameters?: QueryParameters): Stream;
    queryRelated(modifier: QueryModifier): Stream;
    one(queryLike: QueryLike, parameters?: QueryParameters): import("./FutureValue").FutureValue;
    attr(attr: string, queryLike: string, parameters?: QueryParameters): import("./FutureValue").FutureAttr;
    oneAttr(attr: string, queryLike: string, parameters?: QueryParameters): import("./FutureValue").FutureAttr;
    argsQuery(): QueryTuple;
    args(): any;
    get(attr: string): string | null;
    getOptional(attr: string, defaultValue: any): any;
    getInt(attr: string): number;
    getOptionalInt(attr: string, defaultValue: number): number;
    getEnv(attr: string): any;
    putHeader(obj: Item): void;
    put(obj: Item): void;
    putError(obj: ErrorItem): void;
    callPrepared(stored: StoredQuery, values?: {
        [attr: string]: any;
    }): Stream;
    done(): void;
    async(): void;
    streaming(): void;
    findAndCallMountPoint(tuple: QueryTuple, input: Stream, output: Stream): void;
}
export {};
