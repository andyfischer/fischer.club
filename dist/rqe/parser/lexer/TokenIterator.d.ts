import { Token, LexedText } from '.';
import SourcePos from './SourcePos';
import TokenDef from './TokenDef';
import { LexerSettings } from './LexerSettings';
export declare class TokenIterator {
    position: number;
    tokens: Token[];
    sourceText?: LexedText;
    settings: LexerSettings;
    constructor(text: LexedText, settings?: LexerSettings);
    getPosition(): number;
    restore(position: number): void;
    copy(): TokenIterator;
    next(lookahead?: number): Token;
    nextIs(match: TokenDef, lookahead?: number): boolean;
    nextText(lookahead?: number): string;
    nextIsIdentifier(str: string, lookahead?: number): boolean;
    nextUnquotedText(lookahead?: number): string;
    nextLength(lookahead?: number): number;
    finished(lookahead?: number): boolean;
    advance(): void;
    jumpTo(pos: number): void;
    consume(match?: TokenDef): void;
    consumeWhile(condition: (next: Token) => boolean): void;
    consumeIdentifier(s: string): void;
    consumeAsText(lookahead?: number): string;
    consumeAsUnquotedText(lookahead?: number): string;
    consumeAsTextWhile(condition: (next: Token) => boolean): string;
    tryConsume(match: TokenDef): boolean;
    skipWhile(condition: (next: Token) => boolean): void;
    skipUntilNewline(): void;
    autoSkip(): void;
    skipSpaces(): void;
    skipNewlines(): void;
    lookaheadSkipSpaces(lookahead?: number): number;
    lookaheadAdvance(lookahead: number): void;
    consumeSpace(): void;
    consumeWhitespace(): void;
    toSourcePos(firstToken: Token, lastToken: Token): SourcePos;
    spanToString(startPos: number, endPos: number): string;
}
