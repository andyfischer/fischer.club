import { TableSchema, OnDeleteOption, OnConflictOption, Reference, AttrGenerationMethod } from '../Schema';
import { Graph, QueryExecutionContext } from '../Graph';
import { ItemChangeListener } from '../reactive/ItemChangeEvent';
import { LooseTableSchema, IndexConfiguration } from '../Schema';
import TableIndex from './TableIndex';
import { IDSourceNumber as IDSource } from '../utils/IDSource';
import { ErrorItem } from '../Errors';
import { Constraint } from './Constraints';
import { QueryLike } from '../Query';
import { Stream } from '../Stream';
import { Item } from '../Item';
import { StreamEvent, StreamReceiver } from '../Stream';
import { Step } from '../Step';
export declare type AttrMap = Map<string, any>;
export declare type AttrSet = Map<string, true>;
export declare type LooseAttrList = string | string[];
interface GeneratedValue {
    attr: string;
    prefix: string;
    method: AttrGenerationMethod;
    length: number;
    nextId: number;
}
interface SetupOptions {
    tableId?: string;
    owner?: Graph;
}
export declare class Table<ItemType = any> implements StreamReceiver {
    t: string;
    items: Map<number, ItemType>;
    name: string;
    tableId: string;
    owner: Graph;
    indexes: TableIndex<ItemType>[];
    indexesBySingleAttr: Map<string, TableIndex<ItemType>>;
    constraints: Constraint<ItemType>[];
    generatedValues: GeneratedValue[];
    schema: TableSchema;
    references: Reference[];
    itemChangeListeners?: ItemChangeListener[];
    listenerStreams?: Stream[];
    primaryUniqueAttr?: string;
    isDuringPatch: boolean;
    pendingPatchEvents?: StreamEvent[];
    nextInternalID: IDSource;
    _errors: Table<ErrorItem>;
    _headers: Table<Item>;
    constructor(looseSchema: LooseTableSchema, setupOptions?: SetupOptions);
    size(): number;
    getEffectiveAttrs(): string[];
    _newIndex(config: IndexConfiguration): TableIndex<ItemType>;
    count(): number;
    itemToKey(item: ItemType): {
        [x: string]: any;
    };
    findIndex(attrSet: AttrSet): TableIndex<ItemType>;
    addUniqueConstraint(attrs: LooseAttrList, onConflict?: OnConflictOption): this;
    addReference(attr: string, onDelete: OnDeleteOption): this;
    addForeignKey(attr: string, table: Table, foreignAttr: string, onDelete: OnDeleteOption): this;
    _addIndex(attrs: LooseAttrList): TableIndex<ItemType>;
    addIndex(attrs: LooseAttrList): this;
    hasIndexForAttrs(attrs: string[]): boolean;
    _beforePut(item: ItemType): void;
    receive(event: StreamEvent): void;
    prepare(newValue?: ItemType): ItemType;
    put(newItem: ItemType, putInfo?: any): ItemType;
    putItems(items: ItemType[]): void;
    putError(item: ErrorItem): void;
    putHeader(item: Item): void;
    where(where: any): IterableIterator<ItemType>;
    replaceAll(items: ItemType[]): void;
    getOneByAttrValue(attr: string, value: any): ItemType;
    getOne(where: any): ItemType | null;
    has(where: any): boolean;
    list(): ItemType[];
    toMap(byAttr: string): Map<any, any>;
    [Symbol.iterator](): Generator<ItemType, void, unknown>;
    scan(): Generator<ItemType, void, unknown>;
    scanWhere(where: any): Generator<ItemType, void, unknown>;
    column(attr: string): Generator<any, void, unknown>;
    columnList(attr: string): any[];
    columnAsSet(attr: string): Set<unknown>;
    one(where?: any): ItemType | null;
    listWhere(where: any): ItemType[];
    update(where: any, updater: (item: ItemType) => ItemType, changeInfo?: any): void;
    _deleteOne(item: ItemType, changeInfo?: any): void;
    delete(where: any, changeInfo?: any): void;
    deleteAll(): void;
    addChangeListener(listener: ItemChangeListener): void;
    startListenerStream(step?: Step): Stream;
    internalValidate(): void;
    usageError(message: string): Error;
    hasError(): boolean;
    errors(): Table<ErrorItem>;
    errorsToException(): import("../Errors").ErrorExtended;
    throwErrors(): void;
    rebuildIndexes(): void;
    query(queryLike: QueryLike, parameters?: any, context?: QueryExecutionContext): Stream;
    str(): string;
    strs(): string[];
    dump(): string;
}
export {};
